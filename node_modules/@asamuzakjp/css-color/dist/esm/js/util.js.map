{"version":3,"file":"util.js","sources":["../../../src/js/util.ts"],"sourcesContent":["/**\n * util\n */\n\nimport { TokenType, tokenize } from '@csstools/css-tokenizer';\nimport { CacheItem, createCacheKey, getCache, setCache } from './cache';\nimport { isString } from './common';\nimport { resolveColor } from './resolve';\nimport { Options } from './typedef';\n\n/* constants */\nimport { NAMED_COLORS } from './color';\nimport { SYN_COLOR_TYPE, SYN_MIX, VAL_SPEC } from './constant';\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comma: COMMA,\n  Comment: COMMENT,\n  Delim: DELIM,\n  EOF,\n  Function: FUNC,\n  Ident: IDENT,\n  OpenParen: PAREN_OPEN,\n  Whitespace: W_SPACE\n} = TokenType;\nconst NAMESPACE = 'util';\n\n/* numeric constants */\nconst DEC = 10;\nconst HEX = 16;\nconst DEG = 360;\nconst DEG_HALF = 180;\n\n/* regexp */\nconst REG_COLOR = new RegExp(`^(?:${SYN_COLOR_TYPE})$`);\nconst REG_FN_COLOR =\n  /^(?:(?:ok)?l(?:ab|ch)|color(?:-mix)?|hsla?|hwb|rgba?|var)\\(/;\nconst REG_MIX = new RegExp(SYN_MIX);\n\n/**\n * split value\n * NOTE: comments are stripped, it can be preserved if, in the options param,\n * `delimiter` is either ',' or '/' and with `preserveComment` set to `true`\n * @param value - CSS value\n * @param [opt] - options\n * @returns array of values\n */\nexport const splitValue = (value: string, opt: Options = {}): string[] => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const { delimiter = ' ', preserveComment = false } = opt;\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'splitValue',\n      value\n    },\n    {\n      delimiter,\n      preserveComment\n    }\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as string[];\n  }\n  let regDelimiter;\n  if (delimiter === ',') {\n    regDelimiter = /^,$/;\n  } else if (delimiter === '/') {\n    regDelimiter = /^\\/$/;\n  } else {\n    regDelimiter = /^\\s+$/;\n  }\n  const tokens = tokenize({ css: value });\n  let nest = 0;\n  let str = '';\n  const res: string[] = [];\n  while (tokens.length) {\n    const [type, value] = tokens.shift() as [TokenType, string];\n    switch (type) {\n      case COMMA: {\n        if (regDelimiter.test(value)) {\n          if (nest === 0) {\n            res.push(str.trim());\n            str = '';\n          } else {\n            str += value;\n          }\n        } else {\n          str += value;\n        }\n        break;\n      }\n      case DELIM: {\n        if (regDelimiter.test(value)) {\n          if (nest === 0) {\n            res.push(str.trim());\n            str = '';\n          } else {\n            str += value;\n          }\n        } else {\n          str += value;\n        }\n        break;\n      }\n      case COMMENT: {\n        if (preserveComment && (delimiter === ',' || delimiter === '/')) {\n          str += value;\n        }\n        break;\n      }\n      case FUNC:\n      case PAREN_OPEN: {\n        str += value;\n        nest++;\n        break;\n      }\n      case PAREN_CLOSE: {\n        str += value;\n        nest--;\n        break;\n      }\n      case W_SPACE: {\n        if (regDelimiter.test(value)) {\n          if (nest === 0) {\n            if (str) {\n              res.push(str.trim());\n              str = '';\n            }\n          } else {\n            str += ' ';\n          }\n        } else if (!str.endsWith(' ')) {\n          str += ' ';\n        }\n        break;\n      }\n      default: {\n        if (type === EOF) {\n          res.push(str.trim());\n          str = '';\n        } else {\n          str += value;\n        }\n      }\n    }\n  }\n  setCache(cacheKey, res);\n  return res;\n};\n\n/**\n * extract dashed-ident tokens\n * @param value - CSS value\n * @returns array of dashed-ident tokens\n */\nexport const extractDashedIdent = (value: string): string[] => {\n  if (isString(value)) {\n    value = value.trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey({\n    namespace: NAMESPACE,\n    name: 'extractDashedIdent',\n    value\n  });\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    return cachedResult.item as string[];\n  }\n  const tokens = tokenize({ css: value });\n  const items = new Set();\n  while (tokens.length) {\n    const [type, value] = tokens.shift() as [TokenType, string];\n    if (type === IDENT && value.startsWith('--')) {\n      items.add(value);\n    }\n  }\n  const res = [...items] as string[];\n  setCache(cacheKey, res);\n  return res;\n};\n\n/**\n * is color\n * @param value - CSS value\n * @param [opt] - options\n * @returns result\n */\nexport const isColor = (value: unknown, opt: Options = {}): boolean => {\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n    if (value && isString(value)) {\n      if (/^[a-z]+$/.test(value)) {\n        if (\n          /^(?:currentcolor|transparent)$/.test(value) ||\n          Object.hasOwn(NAMED_COLORS, value)\n        ) {\n          return true;\n        }\n      } else if (REG_COLOR.test(value) || REG_MIX.test(value)) {\n        return true;\n      } else if (REG_FN_COLOR.test(value)) {\n        opt.nullable = true;\n        if (!opt.format) {\n          opt.format = VAL_SPEC;\n        }\n        const resolvedValue = resolveColor(value, opt);\n        if (resolvedValue) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * value to JSON string\n * @param value - CSS value\n * @param [func] - stringify function\n * @returns stringified value in JSON notation\n */\nexport const valueToJsonString = (\n  value: unknown,\n  func: boolean = false\n): string => {\n  if (typeof value === 'undefined') {\n    return '';\n  }\n  const res = JSON.stringify(value, (_key, val) => {\n    let replacedValue;\n    if (typeof val === 'undefined') {\n      replacedValue = null;\n    } else if (typeof val === 'function') {\n      if (func) {\n        replacedValue = val.toString().replace(/\\s/g, '').substring(0, HEX);\n      } else {\n        replacedValue = val.name;\n      }\n    } else if (val instanceof Map || val instanceof Set) {\n      replacedValue = [...val];\n    } else if (typeof val === 'bigint') {\n      replacedValue = val.toString();\n    } else {\n      replacedValue = val;\n    }\n    return replacedValue;\n  });\n  return res;\n};\n\n/**\n * round to specified precision\n * @param value - numeric value\n * @param bit - minimum bits\n * @returns rounded value\n */\nexport const roundToPrecision = (value: number, bit: number = 0): number => {\n  if (!Number.isFinite(value)) {\n    throw new TypeError(`${value} is not a finite number.`);\n  }\n  if (!Number.isFinite(bit)) {\n    throw new TypeError(`${bit} is not a finite number.`);\n  } else if (bit < 0 || bit > HEX) {\n    throw new RangeError(`${bit} is not between 0 and ${HEX}.`);\n  }\n  if (bit === 0) {\n    return Math.round(value);\n  }\n  let val;\n  if (bit === HEX) {\n    val = value.toPrecision(6);\n  } else if (bit < DEC) {\n    val = value.toPrecision(4);\n  } else {\n    val = value.toPrecision(5);\n  }\n  return parseFloat(val);\n};\n\n/**\n * interpolate hue\n * @param hueA - hue value\n * @param hueB - hue value\n * @param arc - shorter | longer | increasing | decreasing\n * @returns result - [hueA, hueB]\n */\nexport const interpolateHue = (\n  hueA: number,\n  hueB: number,\n  arc: string = 'shorter'\n): [number, number] => {\n  if (!Number.isFinite(hueA)) {\n    throw new TypeError(`${hueA} is not a finite number.`);\n  }\n  if (!Number.isFinite(hueB)) {\n    throw new TypeError(`${hueB} is not a finite number.`);\n  }\n  switch (arc) {\n    case 'decreasing': {\n      if (hueB > hueA) {\n        hueA += DEG;\n      }\n      break;\n    }\n    case 'increasing': {\n      if (hueB < hueA) {\n        hueB += DEG;\n      }\n      break;\n    }\n    case 'longer': {\n      if (hueB > hueA && hueB < hueA + DEG_HALF) {\n        hueA += DEG;\n      } else if (hueB > hueA + DEG_HALF * -1 && hueB <= hueA) {\n        hueB += DEG;\n      }\n      break;\n    }\n    case 'shorter':\n    default: {\n      if (hueB > hueA + DEG_HALF) {\n        hueA += DEG;\n      } else if (hueB < hueA + DEG_HALF * -1) {\n        hueB += DEG;\n      }\n    }\n  }\n  return [hueA, hueB];\n};\n"],"names":["value"],"mappings":"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"}