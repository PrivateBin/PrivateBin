{"version":3,"file":"relative-color.js","sources":["../../../src/js/relative-color.ts"],"sourcesContent":["/**\n * relative-color\n */\n\nimport { SyntaxFlag, color as colorParser } from '@csstools/css-color-parser';\nimport {\n  ComponentValue,\n  parseComponentValue\n} from '@csstools/css-parser-algorithms';\nimport { CSSToken, TokenType, tokenize } from '@csstools/css-tokenizer';\nimport {\n  CacheItem,\n  NullObject,\n  createCacheKey,\n  getCache,\n  setCache\n} from './cache';\nimport { NAMED_COLORS, convertColorToRgb } from './color';\nimport { isString, isStringOrNumber } from './common';\nimport { resolveDimension, serializeCalc } from './css-calc';\nimport { resolveColor } from './resolve';\nimport { roundToPrecision, splitValue } from './util';\nimport {\n  ColorChannels,\n  MatchedRegExp,\n  Options,\n  StringColorChannels\n} from './typedef';\n\n/* constants */\nimport {\n  CS_LAB,\n  CS_LCH,\n  FN_LIGHT_DARK,\n  FN_REL,\n  FN_REL_CAPT,\n  FN_VAR,\n  NONE,\n  SYN_COLOR_TYPE,\n  SYN_FN_MATH_START,\n  SYN_FN_VAR,\n  SYN_MIX,\n  VAL_SPEC\n} from './constant';\nconst {\n  CloseParen: PAREN_CLOSE,\n  Comment: COMMENT,\n  Dimension: DIM,\n  EOF,\n  Function: FUNC,\n  Ident: IDENT,\n  Number: NUM,\n  OpenParen: PAREN_OPEN,\n  Percentage: PCT,\n  Whitespace: W_SPACE\n} = TokenType;\nconst { HasNoneKeywords: KEY_NONE } = SyntaxFlag;\nconst NAMESPACE = 'relative-color';\n\n/* numeric constants */\nconst OCT = 8;\nconst DEC = 10;\nconst HEX = 16;\nconst MAX_PCT = 100;\nconst MAX_RGB = 255;\n\n/* type definitions */\n/**\n * @type NumberOrStringColorChannels - color channel\n */\ntype NumberOrStringColorChannels = ColorChannels & StringColorChannels;\n\n/* regexp */\nconst REG_COLOR_CAPT = new RegExp(\n  `^${FN_REL}(${SYN_COLOR_TYPE}|${SYN_MIX})\\\\s+`\n);\nconst REG_CS_HSL = /(?:hsla?|hwb)$/;\nconst REG_CS_CIE = new RegExp(`^(?:${CS_LAB}|${CS_LCH})$`);\nconst REG_FN_MATH_START = new RegExp(SYN_FN_MATH_START);\nconst REG_FN_REL = new RegExp(FN_REL);\nconst REG_FN_REL_CAPT = new RegExp(`^${FN_REL_CAPT}`);\nconst REG_FN_REL_START = new RegExp(`^${FN_REL}`);\nconst REG_FN_VAR = new RegExp(SYN_FN_VAR);\n\n/**\n * resolve relative color channels\n * @param tokens - CSS tokens\n * @param [opt] - options\n * @returns resolved color channels\n */\nexport function resolveColorChannels(\n  tokens: CSSToken[],\n  opt: Options = {}\n): NumberOrStringColorChannels | NullObject {\n  if (!Array.isArray(tokens)) {\n    throw new TypeError(`${tokens} is not an array.`);\n  }\n  const { colorSpace = '', format = '' } = opt;\n  const colorChannels = new Map([\n    ['color', ['r', 'g', 'b', 'alpha']],\n    ['hsl', ['h', 's', 'l', 'alpha']],\n    ['hsla', ['h', 's', 'l', 'alpha']],\n    ['hwb', ['h', 'w', 'b', 'alpha']],\n    ['lab', ['l', 'a', 'b', 'alpha']],\n    ['lch', ['l', 'c', 'h', 'alpha']],\n    ['oklab', ['l', 'a', 'b', 'alpha']],\n    ['oklch', ['l', 'c', 'h', 'alpha']],\n    ['rgb', ['r', 'g', 'b', 'alpha']],\n    ['rgba', ['r', 'g', 'b', 'alpha']]\n  ]);\n  const colorChannel = colorChannels.get(colorSpace);\n  // invalid color channel\n  if (!colorChannel) {\n    return new NullObject();\n  }\n  const mathFunc = new Set();\n  const channels: [\n    (number | string)[],\n    (number | string)[],\n    (number | string)[],\n    (number | string)[]\n  ] = [[], [], [], []];\n  let i = 0;\n  let nest = 0;\n  let func = false;\n  while (tokens.length) {\n    const token = tokens.shift();\n    if (!Array.isArray(token)) {\n      throw new TypeError(`${token} is not an array.`);\n    }\n    const [type, value, , , detail] = token as [\n      TokenType,\n      string,\n      number,\n      number,\n      { value: string | number } | undefined\n    ];\n    const channel = channels[i];\n    if (Array.isArray(channel)) {\n      switch (type) {\n        case DIM: {\n          const resolvedValue = resolveDimension(token, opt);\n          if (isString(resolvedValue)) {\n            channel.push(resolvedValue);\n          } else {\n            channel.push(value);\n          }\n          break;\n        }\n        case FUNC: {\n          channel.push(value);\n          func = true;\n          nest++;\n          if (REG_FN_MATH_START.test(value)) {\n            mathFunc.add(nest);\n          }\n          break;\n        }\n        case IDENT: {\n          // invalid channel key\n          if (!colorChannel.includes(value)) {\n            return new NullObject();\n          }\n          channel.push(value);\n          if (!func) {\n            i++;\n          }\n          break;\n        }\n        case NUM: {\n          channel.push(Number(detail?.value));\n          if (!func) {\n            i++;\n          }\n          break;\n        }\n        case PAREN_OPEN: {\n          channel.push(value);\n          nest++;\n          break;\n        }\n        case PAREN_CLOSE: {\n          if (func) {\n            const lastValue = channel[channel.length - 1];\n            if (lastValue === ' ') {\n              channel.splice(-1, 1, value);\n            } else {\n              channel.push(value);\n            }\n            if (mathFunc.has(nest)) {\n              mathFunc.delete(nest);\n            }\n            nest--;\n            if (nest === 0) {\n              func = false;\n              i++;\n            }\n          }\n          break;\n        }\n        case PCT: {\n          channel.push(Number(detail?.value) / MAX_PCT);\n          if (!func) {\n            i++;\n          }\n          break;\n        }\n        case W_SPACE: {\n          if (channel.length && func) {\n            const lastValue = channel[channel.length - 1];\n            if (typeof lastValue === 'number') {\n              channel.push(value);\n            } else if (\n              isString(lastValue) &&\n              !lastValue.endsWith('(') &&\n              lastValue !== ' '\n            ) {\n              channel.push(value);\n            }\n          }\n          break;\n        }\n        default: {\n          if (type !== COMMENT && type !== EOF && func) {\n            channel.push(value);\n          }\n        }\n      }\n    }\n  }\n  const channelValues = [];\n  for (const channel of channels) {\n    if (channel.length === 1) {\n      const [resolvedValue] = channel;\n      if (isStringOrNumber(resolvedValue)) {\n        channelValues.push(resolvedValue);\n      }\n    } else if (channel.length) {\n      const resolvedValue = serializeCalc(channel.join(''), {\n        format\n      });\n      channelValues.push(resolvedValue);\n    }\n  }\n  return channelValues as NumberOrStringColorChannels;\n}\n\n/**\n * extract origin color\n * @param value - CSS color value\n * @param [opt] - options\n * @returns origin color value\n */\nexport function extractOriginColor(\n  value: string,\n  opt: Options = {}\n): string | NullObject {\n  const { colorScheme = 'normal', currentColor = '', format = '' } = opt;\n  if (isString(value)) {\n    value = value.toLowerCase().trim();\n    if (!value) {\n      return new NullObject();\n    }\n    if (!REG_FN_REL_START.test(value)) {\n      return value;\n    }\n  } else {\n    return new NullObject();\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'extractOriginColor',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    return cachedResult.item as string;\n  }\n  if (/currentcolor/.test(value)) {\n    if (currentColor) {\n      value = value.replace(/currentcolor/g, currentColor);\n    } else {\n      setCache(cacheKey, null);\n      return new NullObject();\n    }\n  }\n  let colorSpace = '';\n  if (REG_FN_REL_CAPT.test(value)) {\n    [, colorSpace] = value.match(REG_FN_REL_CAPT) as MatchedRegExp;\n  }\n  opt.colorSpace = colorSpace;\n  if (value.includes(FN_LIGHT_DARK)) {\n    const colorParts = value\n      .replace(new RegExp(`^${colorSpace}\\\\(`), '')\n      .replace(/\\)$/, '');\n    const [, originColor = ''] = splitValue(colorParts);\n    const specifiedOriginColor = resolveColor(originColor, {\n      colorScheme,\n      format: VAL_SPEC\n    }) as string;\n    if (specifiedOriginColor === '') {\n      setCache(cacheKey, null);\n      return new NullObject();\n    }\n    if (format === VAL_SPEC) {\n      value = value.replace(originColor, specifiedOriginColor);\n    } else {\n      const resolvedOriginColor = resolveColor(specifiedOriginColor, opt);\n      if (isString(resolvedOriginColor)) {\n        value = value.replace(originColor, resolvedOriginColor);\n      }\n    }\n  }\n  if (REG_COLOR_CAPT.test(value)) {\n    const [, originColor] = value.match(REG_COLOR_CAPT) as MatchedRegExp;\n    const [, restValue] = value.split(originColor) as MatchedRegExp;\n    if (/^[a-z]+$/.test(originColor)) {\n      if (\n        !/^transparent$/.test(originColor) &&\n        !Object.hasOwn(NAMED_COLORS, originColor)\n      ) {\n        setCache(cacheKey, null);\n        return new NullObject();\n      }\n    } else if (format === VAL_SPEC) {\n      const resolvedOriginColor = resolveColor(originColor, opt);\n      if (isString(resolvedOriginColor)) {\n        value = value.replace(originColor, resolvedOriginColor);\n      }\n    }\n    if (format === VAL_SPEC) {\n      const tokens = tokenize({ css: restValue });\n      const channelValues = resolveColorChannels(tokens, opt);\n      if (channelValues instanceof NullObject) {\n        setCache(cacheKey, null);\n        return channelValues;\n      }\n      const [v1, v2, v3, v4] = channelValues;\n      let channelValue = '';\n      if (isStringOrNumber(v4)) {\n        channelValue = ` ${v1} ${v2} ${v3} / ${v4})`;\n      } else {\n        channelValue = ` ${channelValues.join(' ')})`;\n      }\n      if (restValue !== channelValue) {\n        value = value.replace(restValue, channelValue);\n      }\n    }\n    // nested relative color\n  } else {\n    const [, restValue] = value.split(REG_FN_REL_START) as MatchedRegExp;\n    const tokens = tokenize({ css: restValue });\n    const originColor: string[] = [];\n    let nest = 0;\n    while (tokens.length) {\n      const [type, tokenValue] = tokens.shift() as [TokenType, string];\n      switch (type) {\n        case FUNC:\n        case PAREN_OPEN: {\n          originColor.push(tokenValue);\n          nest++;\n          break;\n        }\n        case PAREN_CLOSE: {\n          const lastValue = originColor[originColor.length - 1];\n          if (lastValue === ' ') {\n            originColor.splice(-1, 1, tokenValue);\n          } else if (isString(lastValue)) {\n            originColor.push(tokenValue);\n          }\n          nest--;\n          break;\n        }\n        case W_SPACE: {\n          const lastValue = originColor[originColor.length - 1];\n          if (\n            isString(lastValue) &&\n            !lastValue.endsWith('(') &&\n            lastValue !== ' '\n          ) {\n            originColor.push(tokenValue);\n          }\n          break;\n        }\n        default: {\n          if (type !== COMMENT && type !== EOF) {\n            originColor.push(tokenValue);\n          }\n        }\n      }\n      if (nest === 0) {\n        break;\n      }\n    }\n    const resolvedOriginColor = resolveRelativeColor(\n      originColor.join('').trim(),\n      opt\n    );\n    if (resolvedOriginColor instanceof NullObject) {\n      setCache(cacheKey, null);\n      return resolvedOriginColor;\n    }\n    const channelValues = resolveColorChannels(tokens, opt);\n    if (channelValues instanceof NullObject) {\n      setCache(cacheKey, null);\n      return channelValues;\n    }\n    const [v1, v2, v3, v4] = channelValues;\n    let channelValue = '';\n    if (isStringOrNumber(v4)) {\n      channelValue = ` ${v1} ${v2} ${v3} / ${v4})`;\n    } else {\n      channelValue = ` ${channelValues.join(' ')})`;\n    }\n    value = value.replace(restValue, `${resolvedOriginColor}${channelValue}`);\n  }\n  setCache(cacheKey, value);\n  return value;\n}\n\n/**\n * resolve relative color\n * @param value - CSS relative color value\n * @param [opt] - options\n * @returns resolved value\n */\nexport function resolveRelativeColor(\n  value: string,\n  opt: Options = {}\n): string | NullObject {\n  const { format = '' } = opt;\n  if (isString(value)) {\n    if (REG_FN_VAR.test(value)) {\n      if (format === VAL_SPEC) {\n        return value;\n        // var() must be resolved before resolveRelativeColor()\n      } else {\n        throw new SyntaxError(`Unexpected token ${FN_VAR} found.`);\n      }\n    } else if (!REG_FN_REL.test(value)) {\n      return value;\n    }\n    value = value.toLowerCase().trim();\n  } else {\n    throw new TypeError(`${value} is not a string.`);\n  }\n  const cacheKey: string = createCacheKey(\n    {\n      namespace: NAMESPACE,\n      name: 'resolveRelativeColor',\n      value\n    },\n    opt\n  );\n  const cachedResult = getCache(cacheKey);\n  if (cachedResult instanceof CacheItem) {\n    if (cachedResult.isNull) {\n      return cachedResult as NullObject;\n    }\n    return cachedResult.item as string;\n  }\n  const originColor = extractOriginColor(value, opt);\n  if (originColor instanceof NullObject) {\n    setCache(cacheKey, null);\n    return originColor;\n  }\n  value = originColor;\n  if (format === VAL_SPEC) {\n    if (value.startsWith('rgba(')) {\n      value = value.replace(/^rgba\\(/, 'rgb(');\n    } else if (value.startsWith('hsla(')) {\n      value = value.replace(/^hsla\\(/, 'hsl(');\n    }\n    return value;\n  }\n  const tokens = tokenize({ css: value });\n  const components = parseComponentValue(tokens) as ComponentValue;\n  const parsedComponents = colorParser(components);\n  if (!parsedComponents) {\n    setCache(cacheKey, null);\n    return new NullObject();\n  }\n  const {\n    alpha: alphaComponent,\n    channels: channelsComponent,\n    colorNotation,\n    syntaxFlags\n  } = parsedComponents;\n  let alpha: number | string;\n  if (Number.isNaN(Number(alphaComponent))) {\n    if (syntaxFlags instanceof Set && syntaxFlags.has(KEY_NONE)) {\n      alpha = NONE;\n    } else {\n      alpha = 0;\n    }\n  } else {\n    alpha = roundToPrecision(Number(alphaComponent), OCT);\n  }\n  let v1: number | string;\n  let v2: number | string;\n  let v3: number | string;\n  [v1, v2, v3] = channelsComponent;\n  let resolvedValue;\n  if (REG_CS_CIE.test(colorNotation)) {\n    const hasNone = syntaxFlags instanceof Set && syntaxFlags.has(KEY_NONE);\n    if (Number.isNaN(v1)) {\n      if (hasNone) {\n        v1 = NONE;\n      } else {\n        v1 = 0;\n      }\n    } else {\n      v1 = roundToPrecision(v1, HEX);\n    }\n    if (Number.isNaN(v2)) {\n      if (hasNone) {\n        v2 = NONE;\n      } else {\n        v2 = 0;\n      }\n    } else {\n      v2 = roundToPrecision(v2, HEX);\n    }\n    if (Number.isNaN(v3)) {\n      if (hasNone) {\n        v3 = NONE;\n      } else {\n        v3 = 0;\n      }\n    } else {\n      v3 = roundToPrecision(v3, HEX);\n    }\n    if (alpha === 1) {\n      resolvedValue = `${colorNotation}(${v1} ${v2} ${v3})`;\n    } else {\n      resolvedValue = `${colorNotation}(${v1} ${v2} ${v3} / ${alpha})`;\n    }\n  } else if (REG_CS_HSL.test(colorNotation)) {\n    if (Number.isNaN(v1)) {\n      v1 = 0;\n    }\n    if (Number.isNaN(v2)) {\n      v2 = 0;\n    }\n    if (Number.isNaN(v3)) {\n      v3 = 0;\n    }\n    let [r, g, b] = convertColorToRgb(\n      `${colorNotation}(${v1} ${v2} ${v3} / ${alpha})`\n    ) as ColorChannels;\n    r = roundToPrecision(r / MAX_RGB, DEC);\n    g = roundToPrecision(g / MAX_RGB, DEC);\n    b = roundToPrecision(b / MAX_RGB, DEC);\n    if (alpha === 1) {\n      resolvedValue = `color(srgb ${r} ${g} ${b})`;\n    } else {\n      resolvedValue = `color(srgb ${r} ${g} ${b} / ${alpha})`;\n    }\n  } else {\n    const cs = colorNotation === 'rgb' ? 'srgb' : colorNotation;\n    const hasNone = syntaxFlags instanceof Set && syntaxFlags.has(KEY_NONE);\n    if (Number.isNaN(v1)) {\n      if (hasNone) {\n        v1 = NONE;\n      } else {\n        v1 = 0;\n      }\n    } else {\n      v1 = roundToPrecision(v1, DEC);\n    }\n    if (Number.isNaN(v2)) {\n      if (hasNone) {\n        v2 = NONE;\n      } else {\n        v2 = 0;\n      }\n    } else {\n      v2 = roundToPrecision(v2, DEC);\n    }\n    if (Number.isNaN(v3)) {\n      if (hasNone) {\n        v3 = NONE;\n      } else {\n        v3 = 0;\n      }\n    } else {\n      v3 = roundToPrecision(v3, DEC);\n    }\n    if (alpha === 1) {\n      resolvedValue = `color(${cs} ${v1} ${v2} ${v3})`;\n    } else {\n      resolvedValue = `color(${cs} ${v1} ${v2} ${v3} / ${alpha})`;\n    }\n  }\n  setCache(cacheKey, resolvedValue);\n  return resolvedValue;\n}\n"],"names":["colorParser"],"mappings":"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"}